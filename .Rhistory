mean(exp(X))
mean(exp(X))
setseed(123)
seed(123)
set.seed(123)
X <- rnorm(100000, mean = 1, sd = 1)
mean(exp(X))
# Generate Random Variables
#  Use R to generate a random sample from population.
set.seed(123)
X <- rnorm(100000, mean = 3, sd = 1)
# Compute Summaries
mean(exp(X))
coin <- rbinom(200, size=1, prob=0.5)
# Nick Harrelson
# MA 386
# Simulation Portfolio
# 10-16-2017
library(ggplot2)
#generate data
set.seed(20171016)
blood <- rbinom(12800, size=1, prob=0.011)
#function that outputs number of tests (for B) given a dataset and k value
b.test <- function(data, k){
N <- 12800/k
num.tests <- 0
for (i in 1:N){
# group data #edit second index, equal to 12800 if it exceeds
top <- (((i-1)*k)+k)
if (top > 12800){top <- 12800}
group <- data[(((i-1)*k)+1):top]
# sum positives
check <- sum(group)
# add one for overall test
num.tests <- num.tests + 1
# add k for indiv. tests if neccessary
if (check > 0){
num.tests <- num.tests + length(group)
}
}
num.tests
}
# initialize vector to save tests (could probably be done less ugly)
tests <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
# loop through function for different k values
for (k in 1:20){
tests[k] <- b.test(blood,k)
}
# plot for visualization
x1 <- {1:20}
df <- data.frame(x=x1, y = tests)
ggplot(df, aes(x, y)) + geom_smooth()
# Nick Harrelson
# MA 386
# Simulation Portfolio
# 10-16-2017
library(ggplot2)
#generate data
set.seed(20171016)
blood <- rbinom(12800, size=1, prob=0.011)
#function that outputs number of tests (for B) given a dataset and k value
b.test <- function(data, k){
N <- 12800/k
num.tests <- 0
for (i in 1:N){
# group data #edit second index, equal to 12800 if it exceeds
top <- (((i-1)*k)+k)
if (top > 12800){top <- 12800}
group <- data[(((i-1)*k)+1):top]
# sum positives
check <- sum(group)
# add one for overall test
num.tests <- num.tests + 1
# add k for indiv. tests if neccessary
if (check > 0){
num.tests <- num.tests + length(group)
}
}
num.tests
}
# initialize vector to save tests (could probably be done less ugly)
tests <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
# loop through function for different k values
for (k in 1:20){
tests[k] <- b.test(blood,k)
}
# plot for visualization
x1 <- {1:20}
df <- data.frame(x=x1, y = tests)
ggplot(df, aes(x, y)) + geom_bar()
ggplot(df, aes(x, y)) + geom_bar()
df <- data.frame(k=x1, tests = tests)
ggplot(df, aes(k, tests)) + geom_bar(stat = "identity")
ggplot(df, aes(k, tests)) + geom_bar(stat = "identity") + ylab("# of Tests Performed")
df
# Nick Harrelson
# MA 386
# Simulation Portfolio
# 10-16-2017
library(ggplot2)
#generate data
set.seed(20171016)
blood <- rbinom(12800, size=1, prob=0.011)
#function that outputs number of tests (for B) given a dataset and k value
b.test <- function(data, k){
N <- 12800/k
num.tests <- 0
for (i in 1:N){
# group data #edit second index, equal to 12800 if it exceeds
top <- (((i-1)*k)+k)
if (top > 12800){top <- 12800}
group <- data[(((i-1)*k)+1):top]
# sum positives
check <- sum(group)
# add one for overall test
num.tests <- num.tests + 1
# add k for indiv. tests if neccessary
if (check > 0){
num.tests <- num.tests + length(group)
}
}
num.tests
}
# initialize vector to save tests (could probably be done less ugly)
tests <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
# loop through function for different k values
for (k in 1:40){
tests[k] <- b.test(blood,k)
}
# plot for visualization
x1 <- {1:20}
df <- data.frame(k=x1, tests = tests)
ggplot(df, aes(k, tests)) + geom_bar(stat = "identity") + ylab("# of Tests Performed")
# Nick Harrelson
# MA 386
# Simulation Portfolio
# 10-16-2017
library(ggplot2)
#generate data
set.seed(20171016)
blood <- rbinom(12800, size=1, prob=0.011)
#function that outputs number of tests (for B) given a dataset and k value
b.test <- function(data, k){
N <- 12800/k
num.tests <- 0
for (i in 1:N){
# group data #edit second index, equal to 12800 if it exceeds
top <- (((i-1)*k)+k)
if (top > 12800){top <- 12800}
group <- data[(((i-1)*k)+1):top]
# sum positives
check <- sum(group)
# add one for overall test
num.tests <- num.tests + 1
# add k for indiv. tests if neccessary
if (check > 0){
num.tests <- num.tests + length(group)
}
}
num.tests
}
# initialize vector to save tests (could probably be done less ugly)
tests <- c()
# loop through function for different k values
for (k in 1:40){
tests[k] <- b.test(blood,k)
}
# plot for visualization
x1 <- {1:40}
df <- data.frame(k=x1, tests = tests)
ggplot(df, aes(k, tests)) + geom_bar(stat = "identity") + ylab("# of Tests Performed")
df
#-----------------------------------------------------------------------------
# @author: Ishan Saraf, Nick Harrelson
# @date: October 29th, 2017
# This file combines the use of force and calls for service datasets.
#-----------------------------------------------------------------------------
# Loading required libraries
library(dplyr)
library(caret)
library(e1071)
# Read 911 call data
datapath <- "./Data/PDI_Police_Calls_For_Service__CAD_.csv"
cinci <- read.csv(datapath, header = TRUE)
# Read force data
forcepath <- "./Data/PDI_Use_of_Force.csv"
UOF <- read.csv(forcepath, header = TRUE)
# Get rid of empty columns
cinci <- cinci %>% mutate(INCIDENT_TYPE_DESC = NULL) %>% mutate(PRIORITY_COLOR = NULL)
# Match up use of force incidents with call incidents
matches <- cinci$EVENT_NUMBER %in% intersect(cinci$EVENT_NUMBER, UOF$CFS_NO)
# Append this list to entire dataframe
cinci <- cbind(cinci, as.data.frame(matches))
setwd("~/GitHub/PoliceDataChallenge2017")
library(dplyr)
library(caret)
library(e1071)
datapath <- "./Data/PDI_Police_Calls_For_Service__CAD_.csv"
cinci <- read.csv(datapath, header = TRUE)
datapath <- "./Data/PDI_Police_Calls_For_Service__CAD_.csv"
cinci <- read.csv(datapath, header = TRUE)
#-----------------------------------------------------------------------------
# @author: Ishan Saraf, Nick Harrelson
# @date: October 29th, 2017
# This file combines the use of force and calls for service datasets.
#-----------------------------------------------------------------------------
# Loading required libraries
library(dplyr)
library(caret)
library(e1071)
# Read 911 call data
datapath <- "./Data/PDI_Police_Calls_For_Service__CAD_.csv"
cinci <- read.csv(datapath, header = TRUE)
# Read force data
forcepath <- "./Data/PDI_Use_of_Force.csv"
UOF <- read.csv(forcepath, header = TRUE)
# Get rid of empty columns
cinci <- cinci %>% mutate(INCIDENT_TYPE_DESC = NULL) %>% mutate(PRIORITY_COLOR = NULL)
# Match up use of force incidents with call incidents
matches <- cinci$EVENT_NUMBER %in% intersect(cinci$EVENT_NUMBER, UOF$CFS_NO)
# Append this list to entire dataframe
cinci <- cbind(cinci, as.data.frame(matches))
head(cinci)
cinci <- cinci %>% mutate(DATE = substr(CREATE_TIME_INCIDENT,1,10))
View(cinci)
View(cinci)
cinci <- cinci %>% mutate(DATE = substr(CREATE_TIME_INCIDENT,1,10)) %>% mutate(TIME = substr(CREATE_TIME_INCIDENT,12,22))
cinci <- cinci %>% mutate(INCIDENT_TYPE_DESC = NULL) %>%
mutate(PRIORITY_COLOR = NULL) %>%
mutate(AGENCY = NULL) %>%
mutate(DATE = substr(CREATE_TIME_INCIDENT,1,10)) %>%
mutate(TIME = substr(CREATE_TIME_INCIDENT,12,22)) %>%
mutate(CREATE_TIME_INCIDENT = NULL)
library(lubridate)
test <- "11/115/1997"
month(test)
test <- "11/15/1997"
month(test)
test <- as.Date("11/15/1997")
test <- mdy("11/15/1997")
month(test)
mday(test)
wday(test)
test <- mdy("10/30/2017")
wday(test)
cinci <- cinci %>% mutate(INCIDENT_TYPE_DESC = NULL) %>%
mutate(PRIORITY_COLOR = NULL) %>%
mutate(AGENCY = NULL) %>%
mutate(DATE = mdy(substr(CREATE_TIME_INCIDENT,1,10))) %>%
mutate(TIME = substr(CREATE_TIME_INCIDENT,12,22)) %>%
mutate(CREATE_TIME_INCIDENT = NULL) %>%
mutate(WEEKDAY = wdy(DATE))
#-----------------------------------------------------------------------------
# @author: Ishan Saraf, Nick Harrelson
# @date: October 29th, 2017
# This file combines the use of force and calls for service datasets.
#-----------------------------------------------------------------------------
# Loading required libraries
library(dplyr)
library(caret)
library(e1071)
library(lubridate)
# Read 911 call data
datapath <- "./Data/PDI_Police_Calls_For_Service__CAD_.csv"
cinci <- read.csv(datapath, header = TRUE)
# Read force data
forcepath <- "./Data/PDI_Use_of_Force.csv"
UOF <- read.csv(forcepath, header = TRUE)
# Get rid of empty columns, split date time into two columns
cinci <- cinci %>% mutate(INCIDENT_TYPE_DESC = NULL) %>%
mutate(PRIORITY_COLOR = NULL) %>%
mutate(AGENCY = NULL) %>%
mutate(DATE = mdy(substr(CREATE_TIME_INCIDENT,1,10))) %>%
mutate(TIME = substr(CREATE_TIME_INCIDENT,12,22)) %>%
mutate(CREATE_TIME_INCIDENT = NULL) %>%
mutate(WEEKDAY = wdy(DATE))
# Match up use of force incidents with call incidents
matches <- cinci$EVENT_NUMBER %in% intersect(cinci$EVENT_NUMBER, UOF$CFS_NO)
# Append this list to entire dataframe
cinci <- cbind(cinci, as.data.frame(matches))
wdy(cinci$DATE[1])
library(lubridate)
wdy(cinci$DATE[1])
wday(cinci$DATE[1])
cinci$DATE[1]
cinci$DATE[2]
seq(from = 1, to = 3, by = 1)
x_index <- rep(seq(from = 1, to = 3, by = 1),3)
x_index
y_index
y_index <- rep(seq(from = 1, to = 3, by = 1),3)
x_index
y_index
y_index <- sort(rep(seq(from = 1, to = 3, by = 1),3), decreasing = FALSE)
y_index
x_index
seq(1,10,length=7)
x_bounds <- seq(left_bound, right_bound, length = grid_size+1)
grid_size <- 3
x_index <- rep(seq(from = 1, to = grid_size, by = 1),grid_size)
y_index <- sort(rep(seq(from = 1, to = grid_size, by = 1),grid_size), decreasing = FALSE)
left_bound <- 0
right_bound <- 10
top_bound <- 10
bottom_bound <- 0
x_bounds <- seq(left_bound, right_bound, length = grid_size+1)
x_bounds
x_bounds(1)
x_bounds[1]
x_bounds[1:3]
#assumes a square grid
grid_size <- 3
#assigns indexes to grid spaces
#origin is at top left
x_index <- rep(seq(from = 1, to = grid_size, by = 1),grid_size)
y_index <- sort(rep(seq(from = 1, to = grid_size, by = 1),grid_size), decreasing = FALSE)
left_bound <- 0
right_bound <- 10
top_bound <- 10
bottom_bound <- 0
x_bounds <- seq(left_bound, right_bound, length = grid_size+1)
left_x <- rep(x_bounds[1:grid_size],grid_size)
right_x <- rep(x_bounds[2:grid_size+1],grid_size)
y_bounds <- seq(bottom_bound, top_bound, length = grid_size+1)
#assumes a square grid
grid_size <- 3
#assigns indexes to grid spaces
#origin is at top left
x_index <- rep(seq(from = 1, to = grid_size, by = 1),grid_size)
y_index <- sort(rep(seq(from = 1, to = grid_size, by = 1),grid_size), decreasing = FALSE)
left_bound <- 0
right_bound <- 10
top_bound <- 10
bottom_bound <- 0
x_bounds <- seq(left_bound, right_bound, length = grid_size+1)
left_x <- rep(x_bounds[1:grid_size],grid_size)
right_x <- rep(x_bounds[2:grid_size+1],grid_size)
y_bounds <- seq(bottom_bound, top_bound, length = grid_size+1)
bottom_y <- rep(y_bounds[1:grid_size],grid_size)
top_y <- rep(y_bounds[2:grid_size+1],grid_size)
y_bounds[1:grid_size]
y_bounds[2:grid_size+1]
y_bounds
y_bounds[2:(grid_size+1)]
#assumes a square grid
grid_size <- 3
#assigns indexes to grid spaces
#origin is at top left
x_index <- rep(seq(from = 1, to = grid_size, by = 1),grid_size)
y_index <- sort(rep(seq(from = 1, to = grid_size, by = 1),grid_size), decreasing = FALSE)
left_bound <- 0
right_bound <- 10
top_bound <- 10
bottom_bound <- 0
x_bounds <- seq(left_bound, right_bound, length = grid_size+1)
left_x <- rep(x_bounds[1:grid_size],grid_size)
right_x <- rep(x_bounds[2:(grid_size+1)],grid_size)
y_bounds <- seq(bottom_bound, top_bound, length = grid_size+1)
bottom_y <- rep(y_bounds[1:grid_size],grid_size)
top_y <- rep(y_bounds[2:(grid_size+1)],grid_size)
df <- df(x_index,y_index,)
df <- df(x_index,y_index,left_x, right_x, bottom_y, top_y)
df <- df(x_index,y_index,left_x, right_x, bottom_y)
num_thefts <- rep(0,grid_size^2)
df <- data.frame(x_index,y_index,left_x, right_x, bottom_y)
df <- data.frame(x_index,y_index,left_x, right_x, bottom_y, top_y)
df
#assumes a square grid
grid_size <- 3
#assigns indexes to grid spaces
#origin is at top left
x_index <- rep(seq(from = 1, to = grid_size, by = 1),grid_size)
y_index <- sort(rep(seq(from = 1, to = grid_size, by = 1),grid_size), decreasing = FALSE)
left_bound <- 0
right_bound <- 10
top_bound <- 10
bottom_bound <- 0
x_bounds <- seq(left_bound, right_bound, length = grid_size+1)
left_x <- rep(x_bounds[1:grid_size],grid_size)
right_x <- rep(x_bounds[2:(grid_size+1)],grid_size)
y_bounds <- seq(bottom_bound, top_bound, length = grid_size+1)
bottom_y <- sort(rep(y_bounds[1:grid_size],grid_size), decreasing = FALSE)
top_y <- sort(rep(y_bounds[2:(grid_size+1)],grid_size), decreasing = FALSE)
num_thefts <- rep(0,grid_size^2)
df <- data.frame(x_index,y_index,left_x, right_x, bottom_y, top_y)
df
df <- data.frame(x_index,y_index,left_x, right_x, bottom_y, top_y, num_thefts)
df
length(df)
df$x_index[4]
df$x_index[8]
which(df$x_index == 1)
df$x_index[1 4 7]
df$x_index[which(df$x_index == 1)]
df[which(df$x_index == 1)]
df
which(df$x_index == 1)
df[which(df$x_index == 1)]
df[df$x_index == 1]
df
filter(df, x_index == 1)
orig_index <- c(1:grid_size^2)
df <- data.frame(x_index,y_index,left_x, right_x, bottom_y, top_y, num_thefts, orig_index)
x1 <- c(4,5,7,8,8.5,9)
y1 <- x(9,5,9,8,5,2)
y1 <- c(9,5,9,8,5,2)
bucket <- data.frame(x1,y1)
bucket <- data.frame(long = x1,lat =y1)
bucket
grid
bucket
df
append_grid(df,bucket, 1, 1)
append_grid <- function(grid, theft_bucket, hour, day){
for(i in 1:length(theft_bucket)){
x <- grid$x_index[min(which(theft_bucket$long[i] > grid$left_x))]
y <- grid$x_index[min(which(theft_bucket$lat[i] > grid$left_x)) & grid$x_index == x]
row <- grid %>% filter(x_index == x) %>% filter(y_index == y)
grid$num_thefts[row$orig_index] <- grid$num_thefts[row$orig_index] + 1
}
grid
}
append_grid <- function(grid, theft_bucket, hour, day){
for(i in 1:length(theft_bucket)){
x <- grid$x_index[min(which(theft_bucket$long[i] > grid$left_x))]
y <- grid$x_index[min(which(theft_bucket$lat[i] > grid$left_x)) & grid$x_index == x]
row <- grid %>% filter(x_index == x) %>% filter(y_index == y)
grid$num_thefts[row$orig_index] <- grid$num_thefts[row$orig_index] + 1
}
grid
}
append_grid(df,bucket, 1, 1)
grid$num_thefts
append_grid$num_thefts
test<-append_grid(df,bucket, 1, 1)
test$num_thefts
test$num_thefts[1]
df$x_index[min(which(bucket$long[i] > df$left_x))]
df$x_index[min(which(bucket$long[1] > df$left_x))]
length(bucket)
size(bucket)
size(bucket)
nrow(bucket)
#function to append grid for a specific time bucket (lat and long of incidents) on a specific day
append_grid <- function(grid, theft_bucket, hour, day){
for(i in 1:nrow(theft_bucket)){
x <- grid$x_index[min(which(theft_bucket$long[i] > grid$left_x & theft_bucket$long[i] < grid$right_x))]
y <- grid$x_index[min(which(theft_bucket$lat[i] > grid$bottom_y & theft_bucket$lat[i] < grid$top_y)) & grid$x_index == x]
row <- grid %>% filter(x_index == x) %>% filter(y_index == y)
grid$num_thefts[row$orig_index] <- grid$num_thefts[row$orig_index] + 1
}
grid
}
df
append_grid(df,bucket, 1, 1)
bucket
which(bucket$long[1] > df$left_x & bucket$long[1] < df$right_x)
a<-which(bucket$long[1] > df$left_x & bucket$long[1] < df$right_x)
min(a)
df$x_index[2]
min(which(bucket$lat[1] > df$bottom_y & bucket$lat[1] < df$top_y)) & df$x_index == 2
min(which(bucket$lat[1] > df$bottom_y & bucket$lat[1] < df$top_y)) & df$x_index == 2)
min(which(bucket$lat[1] > df$bottom_y & bucket$lat[1] < df$top_y) & df$x_index == 2)
which(bucket$lat[1] > df$bottom_y & bucket$lat[1] < df$top_y & df$x_index == 2)
df
#function to append grid for a specific time bucket (lat and long of incidents) on a specific day
append_grid <- function(grid, theft_bucket, hour, day){
for(i in 1:nrow(theft_bucket)){
x <- grid$x_index[min(which(theft_bucket$long[i] > grid$left_x & theft_bucket$long[i] < grid$right_x))]
y <- grid$y_index[which(theft_bucket$lat[i] > grid$bottom_y & theft_bucket$lat[i] < grid$top_y)) & grid$x_index == x]
row <- grid %>% filter(x_index == x) %>% filter(y_index == y)
grid$num_thefts[row$orig_index] <- grid$num_thefts[row$orig_index] + 1
}
grid
}
append_grid <- function(grid, theft_bucket, hour, day){
for(i in 1:nrow(theft_bucket)){
x <- grid$x_index[min(which(theft_bucket$long[i] > grid$left_x & theft_bucket$long[i] < grid$right_x))]
y <- grid$y_index[min(which(theft_bucket$lat[i] > grid$bottom_y & theft_bucket$lat[i] < grid$top_y)) & grid$x_index == x]
row <- grid %>% filter(x_index == x) %>% filter(y_index == y)
grid$num_thefts[row$orig_index] <- grid$num_thefts[row$orig_index] + 1
}
grid
}
append_grid(df,bucket,1,1)
append_grid <- function(grid, theft_bucket, hour, day){
for(i in 1:nrow(theft_bucket)){
x <- grid$x_index[min(which(theft_bucket$long[i] > grid$left_x & theft_bucket$long[i] < grid$right_x))]
small <- grid %>% filter(x_index == x)
y <- small$y_index[min(which(theft_bucket$lat[i] > grid$bottom_y & theft_bucket$lat[i] < grid$top_y))]
row <- grid %>% filter(x_index == x) %>% filter(y_index == y)
grid$num_thefts[row$orig_index] <- grid$num_thefts[row$orig_index] + 1
}
grid
}
append_grid(df,bucket,1,1)
df %>% filter(x_index == 2)
test <- df %>% filter(x_index == 2)
test %>% filter(9 < top_y & 9 > bottom_y)
#function to append grid for a specific time bucket (lat and long of incidents) on a specific day
append_grid <- function(grid, theft_bucket, hour, day){
for(i in 1:nrow(theft_bucket)){
x <- grid$x_index[min(which(theft_bucket$long[i] > grid$left_x & theft_bucket$long[i] < grid$right_x))]
y <- grid %>% filter(x_index = x) %>% filter(theft_bucket$lat[i] < top_y & theft_bucket$lat[i] > bottom_y)
y = y$y_index
row <- grid %>% filter(x_index == x) %>% filter(y_index == y)
grid$num_thefts[row$orig_index] <- grid$num_thefts[row$orig_index] + 1
}
grid
append_grid(df,bucket,1,1)
x
1+1
